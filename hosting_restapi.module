<?php

/**
 * @file
 *   Hosting REST API functions, and Drupal hooks.
 */

define('HOSTING_RESTAPI_ORDER_STATUS_NEW', 1);
define('HOSTING_RESTAPI_ORDER_STATUS_CLONE_INPROGRESS', 2);
define('HOSTING_RESTAPI_ORDER_STATUS_CLONE_COMPLETE', 3);
define('HOSTING_RESTAPI_ORDER_STATUS_IMPORT_INPROGRESS', 4);
define('HOSTING_RESTAPI_ORDER_STATUS_IMPORT_COMPLETE', 5);
define('HOSTING_RESTAPI_ORDER_STATUS_LOGIN_RESET_COMPLETE', 6);

require_once 'hosting_restapi.utils.php';

/**
 * Implements hook_menu().
 */
function hosting_restapi_menu() {
  $items = array();

  $items['hosting/api/site'] = array(
    'title' => 'Manage a site',
    'page callback' => 'hosting_restapi_site',
    'description' => 'Get/post a site',
    'access callback' => TRUE,
    'file' => 'hosting_restapi.site.inc',
  );
  $items['hosting/api/site/config'] = array(
    'title' => 'Manage a site configuration',
    'page callback' => 'hosting_restapi_site_config',
    'description' => 'Get/post a site config',
    'access callback' => TRUE,
    'file' => 'hosting_restapi.site-config.inc',
  );

  return $items;
}

/**
 * Access check, using the $key and optional $secret.
 * This is extremely basic, since not planning on an open service.
 * We are only having two trusted systems communicate with each other.
 *
 * This functions invokes hook_hosting_restapi_check_access().
 * If ANY check is accepted, then the check returns TRUE.
 * If no implementations are found, this check returns TRUE.
 *
 * hosting_saas has a basic optional API key check.
 */
function hosting_restapi_check_access($key = NULL, $secret = NULL) {
  $results = module_invoke_all('hosting_restapi_check_access', $key, $secret);

  if (! count($results)) {
    return TRUE;
  }

  foreach ($results as $key => $val) {
    if ($val) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Checks server capacity limits from hosting_saas.
 * FIXME: shouldn't this be in hosting_saas?
 */
function hosting_restapi_check_capacity($set_error = FALSE) {
  $max_saas_capacity = variable_get('hosting_saas_max_capacity', 0);
  $target_platform = variable_get('hosting_saas_target_platform', NULL);

  if ($target_platform === NULL) {
    if ($set_error) {
      form_set_error('', t('Service not configured!'));
    }

    return FALSE;
  }

  if (intval($max_saas_capacity) <= 0) {
    return TRUE; // Okay
  } 

  $count = hosting_site_count($target_platform);
  if ($count >= $max_saas_capacity) {
    watchdog('hosting_restapi', t('Max capacity reached'), array(), WATCHDOG_ALERT);

    return FALSE;
  }
  else {
    watchdog('hosting_restapi', t('Count / capacity: ' . $count . ' / ' . $max_saas_capacity));
  }
}

/**
 * Log a message for a site.
 *
 * @param String $url
 * @param Int $status
 * @param String $message
 */
function hosting_restapi_log($url, $status, $message) {
  // Fetch the order_id of the site
  $order_id = db_query("SELECT id FROM hosting_restapi_order WHERE site = :url", array(':url' => $url))->fetchField();

  if (! $order_id) {
    drush_log('hosting_restapi_log: This site does not have an order_id. No status logged. URL = ' . $url, 'ok');
    return;
  }

  // Write the log
  $record = new StdClass();
  $record->order_id = $order_id;
  $record->task = $status; // FIXME this is kind of weird..
  $record->message = $message;
  $record->created = time();

  drupal_write_record('hosting_restapi_log', $record);

  // Update the parent status & update time.
  db_query('UPDATE hosting_restapi_order SET updated = :time AND current_status = :status WHERE id = :order_id', array(
    ':time' => time(),
    ':status' => $status,
    ':order_id' => $order_id,
  ));
}

/**
 * Implements hook_post_hosting_TASK_TYPE_task().
 */
function hosting_restapi_post_hosting_clone_task($task, $data) {
  if ($task->ref->type == 'site') {
    hosting_restapi_log($task->task_args['new_uri'], HOSTING_RESTAPI_ORDER_STATUS_CLONE_COMPLETE, 'hosting_restapi_post_hosting_clone_task completed');
  }
}

/**
 * Implements hook_post_hosting_TASK_TYPE_task().
 */
function hosting_restapi_post_hosting_import_task($task, $data) {
  if ($task->ref->type == 'site') {
    hosting_restapi_log($task->context_options['uri'], HOSTING_RESTAPI_ORDER_STATUS_IMPORT_COMPLETE, 'hosting_restapi_post_hosting_import_task completed');

    // Allow other modules to trigger tasks after the status is updated
    module_invoke_all('hosting_restapi_post_task_updated', $task, $data);
  }
}
